# Chapter 6: IP Routing Essentials (IP 라우팅 기초)

이 장에서는 라우팅의 핵심 개념을 다룹니다. 네트워크 엔지니어로서 라우팅을 이해하는 것은 선택이 아니라 필수입니다. 장애가 발생했을 때 "패킷이 어디로 가고 있는지", "왜 목적지에 도달하지 못하는지"를 파악하려면 라우팅의 동작 원리를 정확히 알아야 합니다.

먼저 스위칭과 라우팅의 차이를 명확히 해두겠습니다. **스위칭 ** 은 동일한 네트워크(같은 브로드캐스트 도메인) 내에서 프레임을 전달하는 것이고,**라우팅** 은 서로 다른 네트워크 간에 패킷을 전달하는 과정입니다. 스위치는 MAC 주소를 보고 프레임을 전달하지만, 라우터는 IP 주소를 보고 패킷을 전달합니다.

---

# 1. 라우팅의 기본 개념

## 라우팅이란 무엇인가

**라우팅(Routing)** 은 패킷을 출발지에서 목적지까지 전달하기 위해 최적의 경로를 결정하는 과정입니다. 라우팅은 OSI 모델의 **Layer 3(네트워크 계층)** 에서 동작하며, IP 주소를 기반으로 패킷을 전달합니다.

왜 Layer 2가 아닌 Layer 3에서 동작해야 할까요? MAC 주소는 동일한 브로드캐스트 도메인 내에서만 유효합니다. 여러분의 PC에서 구글 서버로 패킷을 보낸다고 생각해 보십시오. 중간에 수십, 수백 개의 라우터를 거쳐야 하는데, 각 구간마다 MAC 주소는 계속 바뀝니다. 하지만 IP 주소는 출발지부터 목적지까지 변하지 않습니다. 바로 이 점이 Layer 3 라우팅의 핵심입니다. IP 주소는 전 세계적으로 고유하게 식별 가능하기 때문에 어떤 네트워크에 있든 목적지를 찾아갈 수 있습니다.

## 라우터의 동작 과정 - 패킷이 어떻게 전달되는가

**라우터(Router)** 가 패킷을 처리하는 과정을 단계별로 살펴보겠습니다. 이 과정을 이해하면 트러블슈팅할 때 어디서 문제가 발생했는지 파악하기 쉬워집니다.

1.**패킷 수신**: 라우터의 인터페이스로 패킷이 들어옵니다. 이때 라우터는 먼저 Layer 2 헤더(Ethernet 헤더 등)를 확인하여 자신에게 온 프레임이 맞는지 검증합니다. 목적지 MAC 주소가 자신의 인터페이스 MAC이거나 브로드캐스트 주소인 경우에만 처리합니다.

2.**Layer 2 헤더 제거**: 자신에게 온 프레임이 맞다면, Layer 2 헤더를 벗겨내고 내부의 IP 패킷을 확인합니다. 이 과정을 "decapsulation"이라고 합니다.

3.**목적지 IP 주소 확인**: IP 헤더에서 목적지 IP 주소를 확인합니다. 예를 들어 목적지가 192.168.10.50이라면, 라우터는 "이 주소로 가려면 어디로 보내야 하지?"라고 생각하게 됩니다.

4.**라우팅 테이블 조회**: 라우터는 자신의 라우팅 테이블을 조회하여 192.168.10.0/24 네트워크로 가는 경로를 찾습니다. 경로가 있다면 Next-Hop(다음에 보낼 라우터의 IP)과 출구 인터페이스를 확인합니다.

5.**새 Layer 2 헤더 생성**: 출구 인터페이스를 통해 Next-Hop으로 패킷을 보내기 위해 새로운 Layer 2 헤더를 생성합니다. 이때 Next-Hop의 MAC 주소가 필요한데, 이를 ARP(Address Resolution Protocol)를 통해 조회합니다.

6.**패킷 전송**: 새 Layer 2 헤더를 붙인 프레임을 출구 인터페이스로 전송합니다.

이 전체 과정을 **패킷 포워딩(Packet Forwarding)** 이라고 합니다. 중요한 점은 라우터를 거칠 때마다 Layer 2 헤더는 바뀌지만, Layer 3의 출발지/목적지 IP 주소는 변하지 않는다는 것입니다(NAT을 사용하지 않는 한).

---

# 2. 라우팅 테이블 - 라우터의 지도

## 라우팅 테이블이란

**라우팅 테이블(Routing Table)** 은 라우터가 패킷의 전달 경로를 결정하는 데 사용하는 데이터베이스입니다. 비유하자면 라우터의 "지도"와 같습니다. 이 지도에는 "이 목적지로 가려면 어느 방향(인터페이스)으로 가고, 다음에 누구(Next-Hop)에게 전달해야 하는지"가 적혀 있습니다.

라우팅 테이블이 없다면 라우터는 패킷을 어디로 보내야 할지 전혀 알 수 없습니다. 따라서 라우팅 테이블을 어떻게 구성하고 관리하는지가 네트워크 엔지니어의 핵심 업무 중 하나입니다.

## 라우팅 테이블 확인하기

라우팅 테이블을 확인하는 가장 기본적인 명령어는 다음과 같습니다:

```bash
Router# show ip route
```

실제 출력을 보면서 각 부분이 무엇을 의미하는지 자세히 살펴보겠습니다:

```bash
Router# show ip route
Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP
       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area
       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2
       E1 - OSPF external type 1, E2 - OSPF external type 2
       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2

Gateway of last resort is 192.168.1.1 to network 0.0.0.0

      10.0.0.0/8 is variably subnetted, 2 subnets, 2 masks
C        10.1.1.0/24 is directly connected, GigabitEthernet0/0
L        10.1.1.1/32 is directly connected, GigabitEthernet0/0
D     192.168.2.0/24 [90/2170112] via 192.168.1.2, 00:05:23, GigabitEthernet0/1
O     192.168.3.0/24 [110/2] via 192.168.1.3, 00:10:15, GigabitEthernet0/1
S     192.168.4.0/24 [1/0] via 192.168.1.4
S*    0.0.0.0/0 [1/0] via 192.168.1.1
```

## 라우팅 테이블의 각 요소 이해하기

### 1) 라우트 소스 코드 - 이 경로를 어떻게 알게 되었는가

맨 앞의 알파벳은 해당 경로가 어떻게 라우팅 테이블에 들어왔는지를 나타냅니다. 이것을 "라우트 소스(Route Source)"라고 합니다.

| 코드 | 의미 | 설명 |
|------|------|------|
| **C**| Connected | 라우터의 인터페이스에 직접 연결된 네트워크입니다. 인터페이스에 IP 주소를 설정하고 up 상태가 되면 자동으로 생성됩니다. |
|**L**| Local | 라우터 인터페이스 자체의 IP 주소입니다. 항상 /32로 표시됩니다. 라우터가 자신에게 온 패킷을 인식하기 위해 사용합니다. |
|**S**| Static | 관리자가 `ip route` 명령어로 수동 설정한 경로입니다. |
|**D**| EIGRP | EIGRP 프로토콜을 통해 다른 라우터로부터 학습한 경로입니다. |
|**O**| OSPF | OSPF 프로토콜을 통해 학습한 경로입니다. |
|**R**| RIP | RIP 프로토콜을 통해 학습한 경로입니다. |
|**B** | BGP | BGP 프로토콜을 통해 학습한 경로입니다. |

`S*`에서 `*` 표시는 해당 경로가 **기본 경로(Default Route)** 후보임을 의미합니다. 라우팅 테이블에 일치하는 경로가 없을 때 이 경로를 사용하게 됩니다.

### 2) AD와 Metric - 대괄호 안의 숫자들

다음 줄을 보겠습니다:
```
D     192.168.2.0/24 [90/2170112] via 192.168.1.2, 00:05:23, GigabitEthernet0/1
```

대괄호 `[90/2170112]` 안의 숫자는 매우 중요한 의미를 가집니다:

-**첫 번째 숫자 (90)**:**Administrative Distance(AD)**- 이 라우팅 소스를 얼마나 신뢰하는지를 나타냅니다. 낮을수록 더 신뢰합니다.
-**두 번째 숫자 (2170112)**:**Metric**- 동일한 라우팅 프로토콜 내에서 경로의 비용을 나타냅니다. 낮을수록 더 좋은 경로입니다.

이 두 개념은 뒤에서 자세히 설명하겠습니다.

### 3) Next Hop과 출구 인터페이스 - 어디로 보낼 것인가

```
via 192.168.1.2, 00:05:23, GigabitEthernet0/1
```

-**via 192.168.1.2**: 이것이 **Next-Hop** 입니다. 패킷을 192.168.2.0/24 네트워크로 보내려면 먼저 192.168.1.2 라우터로 전달해야 한다는 의미입니다.
-**00:05:23**: 이 경로가 라우팅 테이블에 등록된 후 경과한 시간입니다.
-**GigabitEthernet0/1**: 패킷을 내보낼 ** 출구 인터페이스**입니다.

라우터는 이 정보를 바탕으로 "GigabitEthernet0/1 인터페이스를 통해 192.168.1.2로 패킷을 보내라"고 결정합니다.

## Connected와 Local 경로의 차이

```bash
C        10.1.1.0/24 is directly connected, GigabitEthernet0/0
L        10.1.1.1/32 is directly connected, GigabitEthernet0/0
```

이 두 경로가 왜 모두 필요한지 궁금하실 수 있습니다.

-**C (Connected) 경로**: 10.1.1.0/24는 GigabitEthernet0/0에 연결된 전체 네트워크를 나타냅니다. 10.1.1.1부터 10.1.1.254까지 모든 호스트로 가는 패킷은 이 인터페이스로 나갑니다.

-**L (Local) 경로**: 10.1.1.1/32는 라우터 자신의 인터페이스 IP 주소입니다. /32라는 것은 정확히 이 하나의 주소만을 의미합니다. 이 경로가 있어야 라우터가 자신에게 온 패킷(예: ping, SSH 등)을 인식하고 로컬에서 처리할 수 있습니다.

---

# 3. Administrative Distance (AD) - 누구의 말을 믿을 것인가

## AD가 필요한 이유

실무에서는 종종 여러 라우팅 프로토콜을 동시에 사용합니다. OSPF를 메인으로 사용하면서 특정 경로는 정적 라우팅으로 설정하고, BGP로 외부 네트워크와 연결하는 식입니다. 이런 상황에서 동일한 목적지 네트워크에 대해 서로 다른 라우팅 소스가 각각 경로를 제안할 수 있습니다.

예를 들어 192.168.10.0/24 네트워크에 대해:
- EIGRP가 "10.1.1.2로 보내"라고 알려주고
- OSPF도 "10.1.1.3으로 보내"라고 알려준다면

라우터는 누구의 말을 믿어야 할까요? 바로 이 질문에 답하기 위해 **Administrative Distance(AD)** 라는 개념이 존재합니다.

## AD의 핵심 원칙

>**AD 값이 낮을수록 해당 라우팅 소스를 더 신뢰합니다.**

라우터는 동일한 목적지에 대해 여러 경로가 존재할 때, AD가 가장 낮은 경로만 라우팅 테이블에 등록합니다. 나머지는 무시됩니다.

## AD 값 표 - 반드시 암기해야 합니다

| 라우팅 소스 | AD 값 | 설명 |
|------------|-------|------|
| Connected (직접 연결) | 0 | 라우터가 직접 확인한 정보 |
| Static (정적 라우팅) | 1 | 관리자가 직접 설정한 정보 |
| EIGRP Summary | 5 | EIGRP 요약 경로 |
| eBGP | 20 | 외부 AS에서 직접 받은 BGP |
| EIGRP (Internal) | 90 | EIGRP로 학습한 내부 경로 |
| IGRP | 100 | 구형 프로토콜 (거의 사용 안 함) |
| OSPF | 110 | OSPF로 학습한 경로 |
| IS-IS | 115 | IS-IS로 학습한 경로 |
| RIP | 120 | RIP으로 학습한 경로 |
| EIGRP (External) | 170 | EIGRP로 재배포된 외부 경로 |
| iBGP | 200 | 같은 AS 내의 BGP |
| Unknown/Unreachable | 255 | 사용 불가 (경로 차단 용도) |

>**시험 포인트 **: CCNP 시험에서 AD 값은 정말 자주 출제됩니다. 특히**Connected(0), Static(1), eBGP(20), EIGRP(90), OSPF(110), RIP(120), iBGP(200)** 은 반드시 외우고 있어야 합니다.

## 왜 이런 AD 값이 정해졌을까?

AD 값은 임의로 정해진 것이 아니라 나름의 논리가 있습니다.

**Connected = 0**: 라우터의 인터페이스에 직접 연결된 네트워크입니다. 라우터가 직접 확인한 것이므로 가장 확실한 정보입니다. 이보다 신뢰할 수 있는 정보는 없습니다.

**Static = 1**: 네트워크 관리자가 의도를 가지고 직접 설정한 정보입니다. 관리자가 "이 경로로 가라"고 명시적으로 지시한 것이므로 높은 신뢰도를 부여합니다. 동적 라우팅 프로토콜보다 우선시되어야 관리자의 의도대로 동작합니다.

**eBGP(20) vs iBGP(200)**: 이 차이가 왜 이렇게 클까요? eBGP는 외부 AS에서 직접 받은 정보입니다. 해당 AS가 "우리 네트워크로 오려면 여기로 와"라고 직접 알려준 것이므로 신뢰도가 높습니다. 반면 iBGP는 같은 AS 내의 다른 라우터가 "내가 eBGP로 받은 정보를 너에게 전달해줄게"라며 중계한 정보입니다. 이 경우 OSPF나 EIGRP 같은 IGP가 더 정확한 내부 경로를 알고 있을 수 있으므로 iBGP의 AD를 높게 설정합니다.

**RIP = 120**: RIP은 가장 단순한 라우팅 프로토콜입니다. Metric으로 홉 카운트(Hop Count)만 사용하기 때문에 대역폭이나 지연 같은 품질 요소를 전혀 반영하지 못합니다. 1Gbps 링크 1개를 거치는 것과 56Kbps 링크 1개를 거치는 것이 RIP에서는 같은 Metric입니다. 이런 한계 때문에 상대적으로 낮은 신뢰도(높은 AD)를 부여합니다.

## AD 적용 예시 - 실제로 어떻게 동작하는가

동일한 목적지 192.168.10.0/24에 대해 다음과 같은 경로 정보가 있다고 가정해 봅시다:

```
EIGRP:  192.168.10.0/24 via 10.1.1.2 [90/156160]
OSPF:   192.168.10.0/24 via 10.1.1.3 [110/20]
RIP:    192.168.10.0/24 via 10.1.1.4 [120/3]
```

라우팅 테이블에는 어떤 경로가 등록될까요?

정답은 **EIGRP 경로** 입니다. AD가 90으로 가장 낮기 때문입니다.

여기서 주의할 점이 있습니다. OSPF의 Metric은 20이고 EIGRP의 Metric은 156160입니다. 숫자만 보면 OSPF가 훨씬 좋아 보이지만,**AD 비교가 Metric 비교보다 먼저 수행됩니다**. 서로 다른 라우팅 프로토콜 간의 Metric은 직접 비교할 수 없습니다. 각 프로토콜마다 Metric을 계산하는 방식이 완전히 다르기 때문입니다.

---

# 4. Metric - 같은 프로토콜 내에서의 경로 비교

## AD와 Metric의 역할 구분

이 두 개념의 차이를 명확히 이해하는 것이 중요합니다:

-**AD (Administrative Distance)**: 서로 ** 다른**라우팅 프로토콜/소스 간의 비교에 사용
-**Metric**:** 동일한**라우팅 프로토콜 내에서 여러 경로를 비교할 때 사용

예를 들어 192.168.10.0/24로 가는 경로가 EIGRP에서 2개 발견되었다면:
```
EIGRP:  192.168.10.0/24 via 10.1.1.2 [90/156160]
EIGRP:  192.168.10.0/24 via 10.1.1.3 [90/281600]
```

두 경로 모두 EIGRP이므로 AD는 90으로 동일합니다. 이 경우 Metric을 비교하여 156160이 더 낮은 첫 번째 경로가 선택됩니다.

## 프로토콜별 Metric 계산 방식

각 라우팅 프로토콜은 "좋은 경로"를 판단하는 기준이 다릅니다:

| 프로토콜 | Metric 기준 | 설명 |
|----------|-------------|------|
| RIP | Hop Count | 거쳐가는 라우터의 수만 계산합니다. 최대 15홉까지 지원하며, 16홉은 도달 불가로 간주합니다. |
| OSPF | Cost | 대역폭 기반으로 계산합니다. 기본 공식은 10^8 / 대역폭(bps)입니다. |
| EIGRP | Composite Metric | 대역폭, 지연, 신뢰성, 부하, MTU 등 여러 요소를 조합합니다. 기본적으로 대역폭과 지연만 사용합니다. |
| BGP | Path Attributes | AS-Path 길이, MED, Local Preference 등 다양한 속성을 순차적으로 비교합니다. |

### OSPF Cost 계산의 이해

OSPF Cost는 다음 공식으로 계산됩니다:

```
Cost = Reference Bandwidth / Interface Bandwidth
     = 100,000,000 bps / Interface Bandwidth (bps)
     = 100 Mbps / Interface Bandwidth
```

기본 Reference Bandwidth가 100Mbps이므로:
- 10Mbps 인터페이스: Cost = 100/10 = 10
- 100Mbps 인터페이스: Cost = 100/100 = 1
- 1Gbps 인터페이스: Cost = 100/1000 = 0.1 →**1**(최소값 적용)
- 10Gbps 인터페이스: Cost = 100/10000 = 0.01 →**1**(최소값 적용)

여기서 문제가 보이시나요? 100Mbps, 1Gbps, 10Gbps 인터페이스가 모두 Cost 1을 가집니다. OSPF가 개발되던 1990년대에는 100Mbps가 최고 속도였기 때문에 이런 공식이 만들어졌습니다. 현대 네트워크에서는 고속 링크를 구분하지 못하는 문제가 발생합니다.

**해결책: Reference Bandwidth 조정**

```bash
Router(config-router)# auto-cost reference-bandwidth 10000
```

이 명령어로 Reference Bandwidth를 10Gbps(10000Mbps)로 변경하면:
- 100Mbps: Cost = 10000/100 = 100
- 1Gbps: Cost = 10000/1000 = 10
- 10Gbps: Cost = 10000/10000 = 1

이제 고속 링크를 제대로 구분할 수 있습니다. 단, 이 설정은 **네트워크 내 모든 OSPF 라우터에서 동일하게 적용** 해야 합니다. 그렇지 않으면 라우터마다 Cost 계산이 달라져 비효율적인 경로가 선택될 수 있습니다.

### EIGRP Metric 계산

EIGRP는 더 복잡한 Metric 공식을 사용하지만, 기본 설정에서는 대역폭과 지연만 고려합니다:

```
Metric = 256 × (10^7 / 최소 대역폭(Kbps) + 총 지연/10)
```

-**최소 대역폭**: 경로 상에서 가장 느린 링크의 대역폭
-**총 지연**: 경로 상의 모든 링크 지연의 합

EIGRP가 OSPF보다 더 정교한 Metric을 제공하지만, 계산이 복잡하고 Cisco 전용이라는 단점이 있습니다.

---

# 5. Longest Prefix Match - 가장 중요한 규칙

## 왜 이 규칙이 가장 중요한가

경로 선택에서 **Longest Prefix Match** 규칙은 AD보다도 먼저 적용됩니다. 많은 분들이 "AD가 낮은 경로가 항상 선택된다"고 알고 계시는데, 이는 절반만 맞는 말입니다. 정확한 우선순위는 다음과 같습니다:

```
Longest Prefix Match > AD > Metric
```

## 실제 예시로 이해하기

라우팅 테이블에 다음 경로들이 있다고 가정합니다:

```
10.0.0.0/8        via 192.168.1.1  [110/10]   (OSPF)
10.1.0.0/16       via 192.168.1.2  [90/156160] (EIGRP)
10.1.1.0/24       via 192.168.1.3  [120/3]    (RIP)
10.1.1.128/25     via 192.168.1.4  [1/0]      (Static)
```

목적지가 **10.1.1.150** 인 패킷이 도착했습니다. 어떤 경로를 사용할까요?

단순히 AD만 보면 Static(AD=1)이 가장 낮으니까 192.168.1.4로 보내야 할 것 같지만... 잠깐, 정말 그럴까요?

정답은 **10.1.1.128/25 경로 (via 192.168.1.4)** 입니다. AD가 낮아서가 아니라,**가장 구체적인(가장 긴 프리픽스) 경로** 이기 때문입니다.

## Longest Prefix Match 동작 원리

라우터는 목적지 주소와 각 경로의 네트워크 주소를 비트 단위로 비교하여 **가장 많은 비트가 일치하는 경로** 를 선택합니다.

10.1.1.150을 이진수로 변환하면: 00001010.00000001.00000001.10010110

| 경로 | 프리픽스 길이 | 매칭 비트 수 | 매칭 여부 |
|------|--------------|-------------|-----------|
| 10.0.0.0/8 | 8비트 | 첫 8비트 | ✓ 매칭 |
| 10.1.0.0/16 | 16비트 | 첫 16비트 | ✓ 매칭 |
| 10.1.1.0/24 | 24비트 | 첫 24비트 | ✓ 매칭 |
| 10.1.1.128/25 | 25비트 | 첫 25비트 | ✓ 매칭 (최종 선택) |

10.1.1.150은 10.1.1.128~10.1.1.255 범위에 속하므로 /25 네트워크에 포함됩니다. 25비트가 일치하는 것이 가장 구체적이므로 이 경로가 선택됩니다.

## 실무에서 중요한 이유

이 규칙 때문에 다음과 같은 상황이 발생할 수 있습니다:

```
S     10.1.0.0/16   via 192.168.1.1  [1/0]    ← Static, AD=1
R     10.1.1.0/24   via 192.168.1.2  [120/5]  ← RIP, AD=120
```

10.1.1.50으로 가는 패킷은 어떤 경로를 사용할까요?

**RIP 경로(via 192.168.1.2)** 를 사용합니다. AD가 120으로 Static(AD=1)보다 높지만, /24가 /16보다 더 구체적이기 때문입니다.

이 동작은 의도된 것입니다. 더 구체적인 경로가 있다는 것은 해당 네트워크로 가는 더 정확한 정보가 있다는 의미이기 때문입니다.

## 특정 목적지의 경로 확인 방법

특정 IP 주소가 어떤 경로를 사용하는지 확인하려면:

```bash
Router# show ip route 10.1.1.150
Routing entry for 10.1.1.128/25
  Known via "static", distance 1, metric 0
  Routing Descriptor Blocks:
  * 192.168.1.4
      Route metric is 0, traffic share count is 1
```

이 명령어는 트러블슈팅 시 매우 유용합니다. 라우팅 테이블 전체를 살펴보는 것보다 특정 목적지의 경로를 직접 확인하는 것이 더 정확합니다.

---

# 6. 정적 라우팅 (Static Routing)

## 정적 라우팅이란

**정적 라우팅** 은 네트워크 관리자가 목적지 네트워크로 가는 경로를 직접 수동으로 설정하는 방식입니다. OSPF, EIGRP 같은 동적 라우팅 프로토콜이 라우터 간에 자동으로 경로 정보를 교환하는 것과 달리, 정적 라우팅에서는 모든 경로를 관리자가 일일이 입력해야 합니다.

## 정적 라우팅 설정 방법

### 기본 명령어 형식

```bash
Router(config)# ip route [목적지 네트워크] [서브넷 마스크] [Next-Hop IP 또는 출구 인터페이스] [AD]
```

### 방법 1: Next-Hop IP 주소 지정 (권장)

```bash
Router(config)# ip route 192.168.10.0 255.255.255.0 192.168.1.2
```

이 방법이 권장되는 이유는 라우터가 패킷을 전송할 때 Next-Hop의 MAC 주소를 ARP로 정확히 조회할 수 있기 때문입니다. Ethernet 환경에서는 항상 이 방식을 사용하는 것이 좋습니다.

### 방법 2: 출구 인터페이스 지정

```bash
Router(config)# ip route 192.168.10.0 255.255.255.0 GigabitEthernet0/1
```

이 방법은 **Point-to-Point 링크**(Serial, 전용선 등)에서만 권장됩니다. Point-to-Point 링크는 양쪽에 각각 하나의 장비만 연결되어 있으므로 "이 인터페이스로 나가면 반드시 상대방에게 도달한다"고 확신할 수 있습니다.

Ethernet 환경에서 출구 인터페이스만 지정하면 **Proxy ARP** 문제가 발생할 수 있습니다. Ethernet은 다중 접속 매체이므로 해당 인터페이스에 여러 장비가 연결될 수 있고, 라우터가 목적지 IP로 직접 ARP 요청을 보내게 됩니다. 이로 인해 예상치 못한 동작이나 보안 문제가 발생할 수 있습니다.

### 방법 3: 둘 다 지정 (Fully Specified Static Route)

```bash
Router(config)# ip route 192.168.10.0 255.255.255.0 GigabitEthernet0/1 192.168.1.2
```

출구 인터페이스와 Next-Hop을 모두 지정하는 방법입니다. 가장 명확하고 안전한 방식이지만, 대부분의 경우 Next-Hop만 지정해도 충분합니다.

## 기본 경로 (Default Route)

**기본 경로 ** 는 라우팅 테이블에 일치하는 경로가 없을 때 사용하는 "최후의 수단" 경로입니다.**0.0.0.0/0** 으로 표현되며, 모든 네트워크와 매칭되지만 프리픽스 길이가 0이므로 다른 모든 경로보다 우선순위가 낮습니다.

```bash
Router(config)# ip route 0.0.0.0 0.0.0.0 192.168.1.1
```

설정 후 라우팅 테이블을 확인하면:

```bash
Router# show ip route
...
Gateway of last resort is 192.168.1.1 to network 0.0.0.0
S*    0.0.0.0/0 [1/0] via 192.168.1.1
```

**Gateway of last resort** 가 설정된 것을 확인할 수 있습니다. 이제 라우팅 테이블에 명시적으로 등록되지 않은 모든 목적지로 향하는 패킷은 192.168.1.1로 전송됩니다.

### 실무 활용 예시

기업 네트워크에서 인터넷 연결을 생각해 보십시오. 인터넷에는 수십만 개의 네트워크가 존재합니다. 이 모든 경로를 라우터에 등록하는 것은 불가능합니다. 대신 기본 경로를 ISP 라우터로 설정합니다:

```bash
! ISP 라우터(203.0.113.1)를 기본 경로로 설정
Router(config)# ip route 0.0.0.0 0.0.0.0 203.0.113.1
```

이렇게 하면 내부 네트워크 외의 모든 트래픽(인터넷 트래픽)은 ISP로 전달됩니다.

---

# 7. Floating Static Route - 백업 경로 구성

## 개념과 필요성

네트워크에서 이중화는 매우 중요합니다. 주 경로가 장애를 겪더라도 서비스가 중단되지 않도록 백업 경로를 미리 준비해 두어야 합니다.**Floating Static Route** 는 이를 위한 기법입니다.

아이디어는 간단합니다. 동일한 목적지에 대해 두 개의 정적 경로를 설정하되,**백업 경로의 AD를 주 경로보다 높게 설정** 합니다. 그러면 평소에는 주 경로만 라우팅 테이블에 등록되고, 주 경로가 다운되면 자동으로 백업 경로가 활성화됩니다.

## 설정 방법

```bash
! 주 경로 (AD = 1, 기본값)
Router(config)# ip route 192.168.10.0 255.255.255.0 192.168.1.2

! 백업 경로 (AD = 150)
Router(config)# ip route 192.168.10.0 255.255.255.0 192.168.2.2 150
```

명령어 끝에 추가한 숫자 `150`이 해당 경로의 AD입니다. 기본 Static 경로의 AD가 1이므로, 150으로 설정하면 주 경로가 있는 한 백업 경로는 라우팅 테이블에 나타나지 않습니다.

## 동작 원리 상세 설명

**정상 상태:**

```bash
Router# show ip route static
S     192.168.10.0/24 [1/0] via 192.168.1.2
```

주 경로(AD=1)만 라우팅 테이블에 있습니다. 백업 경로(AD=150)는 라우터의 메모리에 저장되어 있지만, AD가 더 높기 때문에 테이블에 등록되지 않습니다. 이 상태를 "floating"한다고 표현하여 Floating Static Route라는 이름이 붙었습니다.

**주 경로 장애 발생:**

192.168.1.2로 가는 경로에 문제가 생기면(인터페이스 다운, Next-Hop 도달 불가 등), 라우터는 주 경로를 라우팅 테이블에서 제거합니다. 이 순간 백업 경로가 유일한 후보가 되어 자동으로 테이블에 등록됩니다:

```bash
Router# show ip route static
S     192.168.10.0/24 [150/0] via 192.168.2.2
```

**장애 복구 후:**

주 경로가 복구되면 AD가 낮은 주 경로가 다시 테이블에 등록되고, 백업 경로는 다시 floating 상태가 됩니다.

## 실무 예시: 듀얼 ISP 연결

```
                    [ISP-A: 주 회선]
                   /
[내부 네트워크] -- [Router]
                   \
                    [ISP-B: 백업 회선]
```

```bash
! 주 경로: ISP-A (전용선, 빠른 속도)
Router(config)# ip route 0.0.0.0 0.0.0.0 203.0.113.1

! 백업 경로: ISP-B (VPN, 느린 속도) - AD를 200으로 설정
Router(config)# ip route 0.0.0.0 0.0.0.0 198.51.100.1 200
```

평소에는 ISP-A를 통해 인터넷에 접속하고, ISP-A에 장애가 발생하면 자동으로 ISP-B로 전환됩니다.

## AD 값 설정 가이드

백업 경로의 AD는 주 경로보다 높되, 너무 높으면 안 됩니다. 255는 "사용 불가"를 의미하므로 254 이하로 설정해야 합니다.

| 주 경로 타입 | 주 경로 AD | 권장 Floating AD |
|-------------|-----------|-----------------|
| Static | 1 | 2~10 정도 |
| EIGRP | 90 | 95~100 |
| OSPF | 110 | 115~130 |
| 범용 백업 | 다양 | 200~250 |

>**주의**: AD를 255로 설정하면 해당 경로는 절대 사용되지 않습니다. 255는 "unreachable"을 의미하기 때문입니다.

---

# 8. 재귀 라우팅 (Recursive Routing)

## 개념 이해

라우터가 패킷을 전달하려면 최종적으로 "어떤 인터페이스로 내보낼지"와 "Next-Hop의 MAC 주소"를 알아야 합니다. 그런데 Next-Hop이 직접 연결된 네트워크에 있지 않으면 어떻게 될까요?

이 경우 라우터는 Next-Hop에 도달하기 위한 경로를 다시 조회해야 합니다. 이것을 **재귀 라우팅(Recursive Routing)** 또는 **재귀 조회(Recursive Lookup)** 라고 합니다.

## 예시로 이해하기

```bash
Router# show ip route
S     192.168.10.0/24 [1/0] via 10.1.1.2
D     10.1.1.0/24 [90/2170112] via 192.168.1.2, GigabitEthernet0/0
C     192.168.1.0/24 is directly connected, GigabitEthernet0/0
```

192.168.10.0/24로 가는 패킷을 처리해 봅시다:

1. 라우터가 192.168.10.0/24 경로를 찾습니다 → Next-Hop은 10.1.1.2
2. 10.1.1.2는 직접 연결된 네트워크가 아닙니다. 어떻게 가야 할까요?
3. 라우터가 10.1.1.0/24 경로를 다시 조회합니다 → Next-Hop은 192.168.1.2, 출구는 Gi0/0
4. 192.168.1.2는 Gi0/0에 직접 연결된 네트워크에 있습니다. 도달 가능합니다.
5. 최종적으로 패킷은 Gi0/0을 통해 192.168.1.2로 전송됩니다.

이처럼 Next-Hop을 찾기 위해 라우팅 테이블을 여러 번 조회하는 것이 재귀 라우팅입니다.

## 재귀 라우팅의 단점과 CEF

재귀 조회는 CPU 리소스를 소모합니다. 패킷이 도착할 때마다 여러 번의 테이블 조회를 수행해야 하기 때문입니다.

**CEF(Cisco Express Forwarding)** 는 이 문제를 해결합니다. CEF는 재귀 조회 결과를 미리 계산하여 **FIB(Forwarding Information Base)** 에 저장해 둡니다.

```bash
Router# show ip cef 192.168.10.0
192.168.10.0/24
  nexthop 192.168.1.2 GigabitEthernet0/0
```

CEF 테이블에서는 이미 최종 Next-Hop(192.168.1.2)과 출구 인터페이스(Gi0/0)가 계산되어 있습니다. 패킷이 도착하면 재귀 조회 없이 바로 이 정보를 사용하여 전달합니다.

---

# 9. 라우팅 프로토콜 분류

라우팅 프로토콜을 학습하기 전에 전체적인 분류 체계를 이해하는 것이 중요합니다.

## IGP vs EGP

| 구분 | IGP (Interior Gateway Protocol) | EGP (Exterior Gateway Protocol) |
|------|--------------------------------|--------------------------------|
| 사용 범위 | 동일 AS(Autonomous System) 내부 | 서로 다른 AS 간 |
| 프로토콜 | RIP, OSPF, EIGRP, IS-IS | BGP |
| 목적 | 기업/조직 내부 네트워크 연결 | 인터넷, ISP 간 연결 |
| 특징 | 빠른 수렴, 상세한 토폴로지 | 정책 기반, 대규모 확장성 |

**AS(Autonomous System)** 란 동일한 라우팅 정책 하에 운영되는 네트워크의 집합입니다. 각 AS는 IANA에서 할당받은 고유한 AS 번호를 가집니다. 예를 들어 KT, SKT 같은 ISP들은 각각 하나 이상의 AS를 운영합니다.

## Distance Vector vs Link State

IGP는 동작 방식에 따라 두 가지로 분류됩니다:

| 특성 | Distance Vector | Link State |
|------|-----------------|------------|
|**정보 교환 방식**| 이웃에게 전체 라우팅 테이블 전송 | 모든 라우터에게 링크 상태 정보(LSA) 전송 |
|**토폴로지 인식**| 부분적 (이웃이 알려준 정보만 앎) | 전체 (모든 라우터가 동일한 토폴로지 데이터베이스 보유) |
|**경로 계산**| 이웃이 알려준 거리에 자신까지의 거리를 더함 | SPF(Dijkstra) 알고리즘으로 최단 경로 계산 |
|**수렴 속도**| 느림 (정보가 hop-by-hop으로 전파) | 빠름 (모든 라우터가 동시에 동일 정보 보유) |
|**리소스 사용**| 낮음 | 높음 (CPU, 메모리) |
|**대표 프로토콜** | RIP, EIGRP* | OSPF, IS-IS |

*EIGRP는 Distance Vector 기반이지만 Link State의 장점을 일부 도입하여 "Advanced Distance Vector" 또는 "Hybrid"로 분류하기도 합니다.

---

# 10. CEF (Cisco Express Forwarding)

## 패킷 스위칭 방식의 발전

라우터가 패킷을 전달하는 방식은 시간이 지나면서 발전해 왔습니다:

| 방식 | 동작 | 성능 | 설명 |
|------|------|------|------|
| **Process Switching**| 모든 패킷을 CPU가 처리 | 가장 느림 | 초기 라우터 방식. 모든 패킷에 대해 라우팅 테이블 조회 수행 |
|**Fast Switching**| 첫 패킷만 CPU, 이후 캐시 사용 | 중간 | 첫 패킷의 결과를 캐시에 저장하고 동일 목적지 패킷은 캐시 사용 |
|**CEF**| 미리 계산된 FIB 사용 | 가장 빠름 | 라우팅 테이블 변경 시 미리 FIB를 계산해 두고 패킷은 FIB만 참조 |

현대의 Cisco 라우터에서는 CEF가 기본으로 활성화되어 있습니다.

## CEF의 구성 요소

### FIB (Forwarding Information Base)

FIB는 라우팅 테이블을 기반으로 생성된 **전달 전용 테이블** 입니다. 라우팅 테이블과의 가장 큰 차이점은 재귀 조회가 미리 해결되어 있다는 것입니다.

```bash
Router# show ip cef
Prefix               Next Hop             Interface
0.0.0.0/0            192.168.1.1          GigabitEthernet0/0
10.1.1.0/24          192.168.1.2          GigabitEthernet0/0
192.168.1.0/24       attached             GigabitEthernet0/0
192.168.10.0/24      192.168.1.2          GigabitEthernet0/0
```

모든 경로에 대해 최종 Next-Hop과 출구 인터페이스가 직접 표시됩니다.

### Adjacency Table

Adjacency Table은 Next-Hop의 **Layer 2 정보(MAC 주소 등)** 를 저장합니다. 패킷을 전송할 때 새 Layer 2 헤더를 생성해야 하는데, Adjacency Table에 이 정보가 미리 저장되어 있어 즉시 사용할 수 있습니다.

```bash
Router# show adjacency detail
```

## CEF 관련 명령어

```bash
! CEF 전체 상태 확인
Router# show ip cef summary

! 특정 목적지의 CEF 정보 확인
Router# show ip cef 192.168.10.0

! CEF 활성화 (기본적으로 활성화되어 있음)
Router(config)# ip cef

! CEF 비활성화 (권장하지 않음)
Router(config)# no ip cef
```

---

# 11. 정적 라우팅 vs 동적 라우팅 - 언제 무엇을 사용할까

## 정적 라우팅이 적합한 경우

| 상황 | 이유 |
|------|------|
|**소규모 네트워크**| 관리할 경로가 적어 수동 설정이 가능 |
|**스텁 네트워크**| 외부 연결이 하나뿐인 끝단 네트워크는 기본 경로만으로 충분 |
|**기본 경로 설정**| 인터넷 연결용 Default Route는 정적으로 설정하는 것이 일반적 |
|**백업 경로**| Floating Static Route로 백업 구성 |
|**보안 요구**| 동적 라우팅은 업데이트 패킷을 주고받는데, 정적 라우팅은 이런 트래픽이 없음 |
|**제어 필요**| 특정 경로를 관리자가 완전히 통제해야 하는 경우 |

## 동적 라우팅이 적합한 경우

| 상황 | 이유 |
|------|------|
|**대규모 네트워크**| 수백, 수천 개의 경로를 수동 관리하는 것은 불가능 |
|**복잡한 토폴로지**| 다중 경로, 중복 연결이 있는 환경에서는 자동 경로 계산이 필수 |
|**잦은 변경**| 네트워크 추가/제거가 빈번한 환경에서 수동 업데이트는 비현실적 |
|**자동 장애 복구**| 링크 장애 시 자동으로 대체 경로를 찾아줌 |
|**부하 분산**| 동일 Metric 경로 간 자동 부하 분산 지원 |

## 실무에서는 대부분 혼합 사용

실제 기업 환경에서는 두 방식을 함께 사용합니다:

-**내부 네트워크**: OSPF, EIGRP 등 동적 라우팅으로 자동 관리
-**인터넷 연결**: ISP 라우터를 향한 Static Default Route
-**특수 경로**: 관리자가 특별히 제어해야 하는 경로는 Static
-**백업 경로**: Floating Static Route로 장애 대비

---

# 12. 실습: 정적 라우팅 구성

## 토폴로지

```
        10.1.1.0/24              10.1.2.0/24
[PC1]--------[R1]------------------[R2]--------[PC2]
192.168.1.10  |   .1          .2   |   192.168.2.10
              |                    |
        Gi0/0: 10.1.1.1      Gi0/0: 10.1.2.2
        Gi0/1: 192.168.1.1   Gi0/1: 192.168.2.1
```

PC1(192.168.1.10)과 PC2(192.168.2.10)가 서로 통신하도록 정적 라우팅을 구성합니다.

## R1 구성

```bash
R1# configure terminal

! 인터페이스 설정
R1(config)# interface GigabitEthernet0/0
R1(config-if)# ip address 10.1.1.1 255.255.255.0
R1(config-if)# no shutdown
R1(config-if)# exit

R1(config)# interface GigabitEthernet0/1
R1(config-if)# ip address 192.168.1.1 255.255.255.0
R1(config-if)# no shutdown
R1(config-if)# exit

! 정적 라우팅 설정
! PC2 네트워크(192.168.2.0/24)로 가려면 R2(10.1.1.2)로 보내라
R1(config)# ip route 192.168.2.0 255.255.255.0 10.1.1.2

! R2의 내부 인터페이스 네트워크(10.1.2.0/24)도 설정
R1(config)# ip route 10.1.2.0 255.255.255.0 10.1.1.2
```

## R2 구성

```bash
R2# configure terminal

! 인터페이스 설정
R2(config)# interface GigabitEthernet0/0
R2(config-if)# ip address 10.1.2.2 255.255.255.0
R2(config-if)# no shutdown
R2(config-if)# exit

R2(config)# interface GigabitEthernet0/1
R2(config-if)# ip address 192.168.2.1 255.255.255.0
R2(config-if)# no shutdown
R2(config-if)# exit

! 정적 라우팅 설정
! PC1 네트워크(192.168.1.0/24)로 가려면 R1(10.1.2.1)로 보내라
R2(config)# ip route 192.168.1.0 255.255.255.0 10.1.2.1

! R1의 내부 인터페이스 네트워크(10.1.1.0/24)도 설정
R2(config)# ip route 10.1.1.0 255.255.255.0 10.1.2.1
```

## 검증

```bash
R1# show ip route static
S     192.168.2.0/24 [1/0] via 10.1.1.2
S     10.1.2.0/24 [1/0] via 10.1.1.2

R1# ping 192.168.2.10
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 192.168.2.10, timeout is 2 seconds:
!!!!!
Success rate is 100 percent (5/5), round-trip min/avg/max = 1/2/4 ms
```

ping이 성공하면 양방향 라우팅이 정상적으로 구성된 것입니다.

---

# 13. 트러블슈팅

네트워크 연결 문제가 발생했을 때 체계적으로 점검하는 방법을 알아봅니다.

## 단계별 점검 절차

### 1단계: 인터페이스 상태 확인

```bash
Router# show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol
GigabitEthernet0/0     10.1.1.1        YES NVRAM  up                    up
GigabitEthernet0/1     192.168.1.1     YES NVRAM  up                    up
```

Status와 Protocol이 모두 "up"이어야 정상입니다. 둘 중 하나라도 "down"이면 물리적 연결이나 설정 문제가 있는 것입니다.

### 2단계: 라우팅 테이블 확인

```bash
Router# show ip route
Router# show ip route 192.168.10.50
```

목적지로 가는 경로가 라우팅 테이블에 있는지 확인합니다. 특정 IP에 대한 경로를 직접 조회하면 더 정확한 정보를 얻을 수 있습니다.

### 3단계: 경로 추적

```bash
Router# traceroute 192.168.10.50
```

패킷이 어디까지 도달하는지 확인합니다. 중간에 `* * *`가 나타나면 해당 구간에서 문제가 발생한 것입니다.

### 4단계: CEF 확인

```bash
Router# show ip cef 192.168.10.50
```

CEF가 해당 목적지에 대해 어떤 정보를 가지고 있는지 확인합니다. 라우팅 테이블과 CEF의 정보가 일치하지 않으면 CEF를 재동기화해야 할 수 있습니다.

### 5단계: ARP 테이블 확인

```bash
Router# show ip arp
```

Next-Hop의 MAC 주소가 ARP 테이블에 있는지 확인합니다. MAC 주소가 없으면 Layer 2 연결 문제일 수 있습니다.

## 자주 발생하는 문제들

### 비대칭 라우팅 (Asymmetric Routing)

패킷이 가는 경로와 오는 경로가 다른 경우입니다. 자체로는 문제가 아니지만, Stateful 방화벽 환경에서는 세션 추적 문제가 발생할 수 있습니다.

### 라우팅 루프 (Routing Loop)

잘못된 라우팅 설정으로 패킷이 두 라우터 사이를 무한히 왕복하는 경우입니다. TTL이 0이 될 때까지 지속되다가 패킷이 폐기됩니다. Distance Vector 프로토콜에서 주로 발생합니다.

### 블랙홀 라우팅 (Blackhole Routing)

라우팅 테이블에 경로는 있지만, 실제로는 목적지에 도달할 수 없는 경우입니다. 잘못된 Next-Hop 설정이나 요약 경로 문제로 발생할 수 있습니다.

---

# 14. 정리

## 핵심 개념 요약

1. **라우팅**: 서로 다른 네트워크 간에 패킷을 전달하는 과정. Layer 3에서 IP 주소 기반으로 동작.

2.**라우팅 테이블**: 라우터의 "지도". 목적지 네트워크, Next-Hop, 출구 인터페이스, AD, Metric 정보 포함.

3.**Administrative Distance (AD)**: 라우팅 소스의 신뢰도. 낮을수록 우선. 서로 다른 프로토콜 간 비교에 사용.

4.**Metric**: 동일 프로토콜 내 경로 비교 기준. 프로토콜마다 계산 방식이 다름.

5.**Longest Prefix Match**: 가장 구체적인(프리픽스가 긴) 경로 선택. AD보다 우선.

6.**경로 선택 우선순위**: Longest Prefix Match > AD > Metric

7.**정적 라우팅**: 관리자 수동 설정. 소규모, 스텁 네트워크, 기본 경로에 적합.

8.**Floating Static Route**: 백업용 정적 경로. AD를 높게 설정하여 주 경로 장애 시 활성화.

9.**CEF**: 고속 패킷 전달을 위한 Cisco 기술. FIB와 Adjacency Table 사용.

## 필수 암기 AD 값

| 소스 | AD |
|------|-----|
| Connected | 0 |
| Static | 1 |
| eBGP | 20 |
| EIGRP (Internal) | 90 |
| OSPF | 110 |
| RIP | 120 |
| EIGRP (External) | 170 |
| iBGP | 200 |

---

# 다음 장 예고

**다음 장에서는 EIGRP를 다룹니다.**

EIGRP는 Cisco가 개발한 라우팅 프로토콜로, Distance Vector의 단순함과 Link State의 빠른 수렴 속도를 결합한 "Advanced Distance Vector" 방식입니다.

**주요 내용:**
- EIGRP의 동작 원리와 특징
- DUAL 알고리즘 (Diffusing Update Algorithm)
- Successor와 Feasible Successor 개념
- EIGRP Metric 계산 (K 값)
- EIGRP 설정 및 검증 명령어
- EIGRP 최적화 기법
